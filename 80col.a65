;=====================================================================
; Print text using a 2x8 font on either an 80 column screen
; or moving window 20 column screen
;---------------------------------------------------------------------
; Requires 8k+ memory
; Note the zero page locations used and need
; to provide a label shadScr8020 that will have room for
; the shadow screen after it (80x22 bytes).
;---------------------------------------------------------------------
; Copyright (C) 2021 Lawrence Woodman <lwoodman@vlifesystems.com>
; Licensed under an MIT licence.  Please see LICENCE.md for details.
;=====================================================================

; TODO perhaps call this 8020col rather than 80col
; TODO or split into 80col and 20col

; Configuration
SNUMCOL     = 80              ; Number of simulated text columns
                              ; Must be divisible by 4
SNUMROW     = 22              ; Number of simulated text rows
                              ; Must be divisible by 2
RVTVORIGIN  = 20              ; Vertical TV picture origin
NL          = $0A             ; Newline character

; ASCII characters
SPACE       = 32              ; Space character
BS          = 8               ; Backspace character

; Calculated dimensions for 80 column screen
RNUMCOL80   = SNUMCOL/4       ; Real number of text columns
RNUMROW80   = SNUMROW/2       ; Real number of text rows
SLSTCOL80   = SNUMCOL-1       ; Last simulated column

; Dimensions for 20 column screen
RNUMCOL20   = 20
RNUMROW20   = 22

; Dimensions for shadow screen
RNUMCOLSHD  = 80
RNUMROWSHD  = 22

; Colour constants
CLBLACK     = 00
CLBLUE      = 06

; Mode constants
MODE80      = 1               ; 80 column mode
MODE20      = 0               ; 20 column mode

; VIC Registers
VICCR1      = $9001           ; Vertical TV picture origin
VICCR2      = $9002           ; Number of columns, part of screen address
VICCR3      = $9003           ; Number of rows, raster location, char size
VICCR5      = $9005           ; Screen map and character map address

; Display memory location constants
CHRMAPBASE  = $1000           ; Base address of character map
SCRBASE     = $1E00           ; Base address of screen
COLMAPBASE  = $9600           ; Base address of colour map


; Zero Page Variable Locations
CHRADDR     = $01             ; 16-bit character map address
                              ; used for calculations
CHQUARTER   = $03             ; Quarter of character definition right to left
CHHALFOFF   = $04             ; Half of character definition offset (half*8)
CHDEFADDR   = $09             ; 16-bit character def address
STRADDR     = $0D             ; 16-bit address of a string to print
SFROM       = $0F             ; 16-bit scroll from address
STO         = $12             ; 16-bit scroll to address
CHDEF       = $14             ; 8 bytes defining a character
SHADADDR    = $1C             ; 16-bit shadow screen address


            ;--------------------------------
            ; init8020
            ; Init 80/20 character screen
            ;--------------------------------
init8020    lda  #00          ; Init cursor to top left of screen
            sta  crx          ; |
            sta  cry          ; /
            sta  inRedraw     ; Set as not in middle of redraw
            jmp  clrScrShad   ; Clear the shadow screen (RTS)


            ;--------------------------------
            ; start80
            ; Start 80 character screen
            ;--------------------------------
start80     lda  #MODE80      ; Set which mode we are in
            sta  mode8020     ; /
            jsr  cfgScr80     ; Configure screen
            jsr  initClr80    ; Init the colour map
            jsr  initScr80    ; Init the screen
            jmp  clrScr80     ; Clear the screen by clearing character map


            ;--------------------------------
            ; start20
            ; Start 20 character screen
            ;--------------------------------
start20     lda  #MODE20      ; Set which mode we are in
            sta  mode8020     ; /
            lda  #1           ; Set viewable part of screen to first quarter
            jsr  setView20    ; /
            jsr  cfgScr20     ; Configure screen
            jsr  initClr20    ; Init the colour map
            jmp  clrScr20     ; Clear the screen


            ;-----------------------------------------------
            ; setView20
            ; Set the view window on the 20 column screen
            ;-----------------------------------------------
            ; ACC - Quarter to display (1-4)
            ;-----------------------------------------------
setView20   .(
            cmp  #1
            beq  q1
            cmp  #2
            beq  q2
            cmp  #3
            beq  q3
            cmp  #4
            beq  q4
            bne  done

q1          lda  #00          ; Set viewable part of screen
            sta  viewcolge    ; |
            lda  #20          ; |
            sta  viewcollt    ; /
            jmp  done
q2          lda  #20          ; Set viewable part of screen
            sta  viewcolge    ; |
            lda  #40          ; |
            sta  viewcollt    ; /
            jmp  done
q3          lda  #40          ; Set viewable part of screen
            sta  viewcolge    ; |
            lda  #60          ; |
            sta  viewcollt    ; /
            jmp  done
q4          lda  #60          ; Set viewable part of screen
            sta  viewcolge    ; |
            lda  #80          ; |
            sta  viewcollt    ; /
            jmp  done

done        rts
.)

            ;-----------------------------------------------
            ; cfgScr80
            ; Configure screen dimensions, position and
            ; memory locations
            ;-----------------------------------------------
cfgScr80    lda  #RVTVORIGIN
            sta  VICCR1       ; Set vertical TV origin
            lda  #(128|RNUMCOL80)
            sta  VICCR2       ; Set number of columns displayed
                              ; and screen address
            lda  #((RNUMROW80*2)+1)
            sta  VICCR3       ; Set number of rows displayed
                              ; and character size
            lda  #(240|12)    ; Set screen and character map addresses
                              ; to $1E00 and $1000
            sta  VICCR5
            rts


            ;-----------------------------------------------
            ; cfgScr20
            ; Configure screen dimensions, position and
            ; memory locations
            ;-----------------------------------------------
cfgScr20    lda  #RVTVORIGIN
            sta  VICCR1       ; Set vertical TV origin
            lda  #(128|RNUMCOL20)
            sta  VICCR2       ; Set number of columns displayed
                              ; and screen address
            lda  #(RNUMROW20*2)
            sta  VICCR3       ; Set number of rows displayed
                              ; and character size
            lda  #(240|2)     ; Set screen and character map addresses
                              ; to $1E00 and $8800
            sta  VICCR5
            rts


            ;-------------------------------------
            ; clrScr20
            ; Clear the screen 20 column screen
            ;-------------------------------------
clrScr20    .(
            lda  #00
            sta  CHRADDR          ; TODO Change CHRADDR to SCRADDR?
            lda  #>SCRBASE
            sta  CHRADDR+1
            ldy  #00
loop        lda  #SPACE
            sta  (CHRADDR),y      ; Set character map location
            inc  CHRADDR          ; Increment CHRADDR
            bne  doneInc          ; |
            inc  CHRADDR+1        ; /
doneInc     lda  CHRADDR+1
            cmp  #>$2000          ; TODO Replace with constant
            bne  loop
            rts
.)


            ;-------------------------------------
            ; clrScrShad
            ; Clear the shadow screen
            ;-------------------------------------
clrScrShad  .(
            lda  #<shadScr8020
            sta  SHADADDR
            lda  #>shadScr8020
            sta  SHADADDR+1
            ldy  #00
loop        lda  #SPACE
            sta  (SHADADDR),y
            inc  SHADADDR               ; Increment SHADADDR
            bne  doneInc                ; |
            inc  SHADADDR+1             ; /
doneInc     lda  SHADADDR+1             ; Test if at end of shadow screen
            cmp  #>shadScr8020+(80*22)  ; |
            bne  loop                   ; |
            lda  SHADADDR               ; |
            cmp  #<shadScr8020+(80*22)  ; |
            bne  loop                   ; /
            rts
.)


            ;-----------------------------------------------
            ; initClr20
            ; Init the colour map to all a single colour
            ;-----------------------------------------------
initClr20   .(
            ldy  #00
            lda  #CLBLACK
loop        sta  COLMAPBASE, y
            iny
            bne  loop
            rts
.)


            ;-----------------------------------------------
            ; initClr80
            ; Init the colour map to alternate black/blue
            ; colours to help make characters more distinct
            ;-----------------------------------------------
initClr80   .(
            ldy  #00
            lda  #CLBLACK
loop        sta  COLMAPBASE, y
            cmp  #CLBLACK
            beq  toBlue
            lda  #CLBLACK
            jmp  next
toBlue      lda  #CLBLUE
next        iny
            bne  loop
            rts
.)

            ;-----------------------------------------------
            ; initScr80
            ; Fill screen map with characters needed
            ;-----------------------------------------------
            ; TODO improve this loop code
initScr80   .(
            ldy  #(RNUMCOL80*RNUMROW80)
loop        tya
            sta  SCRBASE, y     ; Store character in screen map
            dey
            cpy  #$FF
            bne  loop
            rts
.)


            ;-----------------------------------------------
            ; clrScr80
            ; Clear the screen by zeroing the character map
            ;-----------------------------------------------
clrScr80    .(
            lda  #$00
            sta  CHRADDR
            lda  #>CHRMAPBASE
            sta  CHRADDR+1
            ldy  #00
loop        lda  #00
            sta  (CHRADDR),y      ; Set character map location
            inc  CHRADDR          ; Increment CHRADDR
            bne  doneInc          ; |
            inc  CHRADDR+1        ; /
doneInc     lda  CHRADDR+1
            cmp  #>SCRBASE
            bne  loop
            rts
.)


            ;------------------------------------------
            ; redraw
            ; Redraw the screen from the shadow screen
            ;------------------------------------------
redraw      .(
            lda  #1           ; Set as in middle of redraw
            sta  inRedraw     ; /
            lda  crx          ; Push crx and cry to stack
            pha               ; |
            lda  cry          ; |
            pha               ; /
            lda  #00
            sta  crx
            sta  cry
            lda  #<shadScr8020
            sta  SHADADDR
            lda  #>shadScr8020
            sta  SHADADDR+1
loop        ldy  #00
            lda  (SHADADDR),y
            ldx  crx
            ldy  cry
            jsr  putchxy
            inc  SHADADDR               ; Increment SHADADDR
            bne  doneInc                ; |
            inc  SHADADDR+1             ; /
doneInc     inc  crx
            ldx  crx
            cpx  #RNUMCOLSHD
            beq  newline
            bne  loop
newline     ldx  #00
            stx  crx
nextline    inc  cry
            ldy  cry
            cpy  #RNUMROWSHD
            bne  loop

            pla
            sta  cry
            pla
            sta  crx

            lda  #0           ; Set as not in middle of redraw
            sta  inRedraw     ; /
            rts
.)

            ;------------------------------------------
            ; scrollup
            ; Scroll the screen up
            ;------------------------------------------
scrollup    .(
            jsr  scrollupShad
            lda  mode8020
            cmp  #MODE80
            beq  is80
is20        jmp  scrollup20
is80        jmp  scrollup80
.)


            ;------------------------------------------
            ; scrollup80
            ; Scroll 80 column screen up up two lines
            ;------------------------------------------
scrollup80  .(
            lda  #<(CHRMAPBASE+16*RNUMCOL80)  ; Set copy start locations
            sta  SFROM                        ; |
            lda  #>(CHRMAPBASE+16*RNUMCOL80)  ; |
            sta  SFROM+1                      ; |
            lda  #<CHRMAPBASE                 ; |
            sta  STO                          ; |
            lda  #>CHRMAPBASE                 ; |
            sta  STO+1                        ; /

            ldy  #0
            ldx  #>(16*RNUMCOL80*(RNUMROW80-1))  ; msb size of move
            beq  partPage
pageLoop    lda  (SFROM),y                   ; Copy a page
            sta  (STO),y                     ; |
            iny                              ; |
            bne  pageLoop                    ; /
            inc  SFROM+1                     ; Next page
            inc  STO+1                       ; /
            dex
            bne  pageLoop
partPage    ldx  #<(16*RNUMCOL80*(RNUMROW80-1))
            beq  wipe
partLoop    lda  (SFROM),y                   ; Copy remainder
            sta  (STO),y                     ; |
            iny                              ; |
            dex                              ; |
            bne  partLoop                    ; /

            ; Wipe last two lines
wipe        lda  #<(CHRMAPBASE+(16*RNUMCOL80*(RNUMROW80-1)))
            sta  STO
            lda  #>(CHRMAPBASE+(16*RNUMCOL80*(RNUMROW80-1)))
            sta  STO+1
            ldx  #2           ; Wipe a page and a bit
            ldy  #$FF         ; Wipe a page of memory containing two lines
            lda  #00          ; Use a space to wipe the lines
wipeLoop    sta  (STO),y
            dey
            cpy  #$FF
            bne  wipeLoop

            ; Setup the remainder of the page to be deleted
            inc  STO+1
            ldy  #(16*RNUMCOL80-256)
            dex
            bne  wipeLoop

            lda  #(SNUMROW-2)      ; Set the cursor to one line up from bottom
            sta  cry

            rts
.)


            ;-----------------------------------------
            ; scrollup20
            ; Scroll 20 column screen up one line
            ;-----------------------------------------
scrollup20  .(
            lda  #<(SCRBASE+RNUMCOL20)  ; Set copy start locations
            sta  SFROM                  ; |
            lda  #>(SCRBASE+RNUMCOL20)  ; |
            sta  SFROM+1                ; |
            lda  #<SCRBASE              ; |
            sta  STO                    ; |
            lda  #>SCRBASE              ; |
            sta  STO+1                  ; /

            ldy  #0
            ldx  #>(RNUMCOL20*(RNUMROW20-1))  ; msb size of move
            beq  partPage
pageLoop    lda  (SFROM),y                    ; Copy a page
            sta  (STO),y                      ; |
            iny                               ; |
            bne  pageLoop                     ; /
            inc  SFROM+1                      ; Next page
            inc  STO+1                        ; /
            dex
            bne  pageLoop
partPage    ldx  #<(RNUMCOL20*(RNUMROW20-1))
            beq  wipe
partLoop    lda  (SFROM),y                   ; Copy remainder
            sta  (STO),y                     ; |
            iny                              ; |
            dex                              ; |
            bne  partLoop                    ; /

            ; Wipe last line
wipe        lda  #<(SCRBASE+(RNUMCOL20*(RNUMROW20-1)))
            sta  STO
            lda  #>(SCRBASE+(RNUMCOL20*(RNUMROW20-1)))
            sta  STO+1
            ldy  #RNUMCOL20      ; Wipe a line of characters
            lda  #SPACE          ; Use a space to wipe the lines
wipeLoop    sta  (STO),y
            dey
            bpl  wipeLoop

            lda  #(SNUMROW-1)      ; Set the cursor to the bottom line
            sta  cry

            rts
.)


            ;-----------------------------------------
            ; scrollupShad
            ; Scroll shadow screen up one line
            ;-----------------------------------------
scrollupShad .(
            lda  #<(shadScr8020+RNUMCOLSHD)   ; Set copy start locations
            sta  SFROM                        ; |
            lda  #>(shadScr8020+RNUMCOLSHD)   ; |
            sta  SFROM+1                      ; |
            lda  #<shadScr8020                ; |
            sta  STO                          ; |
            lda  #>shadScr8020                ; |
            sta  STO+1                        ; /

            ldy  #0
            ldx  #>(RNUMCOLSHD*(RNUMROWSHD-1))  ; Number of pages to move
            beq  partPage
pageLoop    lda  (SFROM),y                    ; Copy a page
            sta  (STO),y                      ; |
            iny                               ; |
            bne  pageLoop                     ; /
            inc  SFROM+1                      ; Next page
            inc  STO+1                        ; /
            dex
            bne  pageLoop
partPage    ldx  #<(RNUMCOLSHD*(RNUMROWSHD-1))   ; Remainder of last page
            beq  wipe
partLoop    lda  (SFROM),y                   ; Copy remainder
            sta  (STO),y                     ; |
            iny                              ; |
            dex                              ; |
            bne  partLoop                    ; /

            ; Wipe last line
wipe        lda  #<(shadScr8020+(RNUMCOLSHD*(RNUMROWSHD-1)))  ; lsb
            sta  STO
            lda  #>(shadScr8020+(RNUMCOLSHD*(RNUMROWSHD-1)))  ; msb
            sta  STO+1
            ldy  #RNUMCOLSHD     ; Wipe a line of characters
            lda  #SPACE          ; Use a space to wipe the lines
wipeLoop    sta  (STO),y
            dey
            bpl  wipeLoop

            lda  #(RNUMROWSHD-1)      ; Set the cursor to the bottom line
            sta  cry

            rts
.)

            ;------------------------------------------
            ; putch
            ; Print a character to screen at cursor
            ; and move cursor
            ; This will print NL, BS control characters
            ; and ASCII 32-128 although these will be
            ; folded into single case
            ;------------------------------------------
            ; ACC - character to print
            ;------------------------------------------
putch       .(
            cmp  #NL
            beq  newline      ; If newline character
            cmp  #BS          ; If backspace character
            beq  backspace

            cmp  #SPACE       ; If acc<32 or acc>=129 then ignore
            bcc  done         ; |
            cmp  #129         ; |
            bcs  done         ; /

            ; Print the character
            pha
            lda  crx
            tax
            lda  cry
            tay
            pla
            jsr  putchxy

            ; Move cursor
            lda  crx
            cmp  #SLSTCOL80
            bne  nextCol

            ; Move cursor to next line
newline     lda  #0
            sta  crx
            lda  cry
            cmp  #(SNUMROW-1)
            beq  scroll       ; Scroll up if on last line
            inc  cry
            bne  done         ; Equivalant to JMP

backspace   ; Move cursor back one character and delete character
            ldx  crx          ; If at beginning of line
            beq  crup         ; /
            dec  crx
            jmp  blank
crup        lda  cry          ; If at top left of screen ignore key
            beq  done         ; /
            lda  #79          ; Move to end of previous line
            sta  crx
            dec  cry
blank       lda  #SPACE       ; Blank out the character
            ldx  crx          ; |
            ldy  cry          ; |
            jsr  putchxy      ; |
            jmp  done         ; /

scroll      jsr  scrollup
            jmp  done

nextCol     inc  crx
done        rts
.)


            ;-----------------------------------------
            ; putchxy
            ; Print a character to screen at position
            ; specified on either the 80 columns or
            ; 20 column screen
            ;-----------------------------------------
            ; ACC - character to print
            ;   X - Column on simulated screen
            ;   Y - Row on simulated screen
            ;-----------------------------------------
putchxy     .(
            sta tmpAcc
            pha               ; Push the parameters to the stack
            txa               ; |
            pha               ; |
            tya               ; |
            pha               ; /
            lda  tmpAcc
            jsr  storexyShd   ; Store the character to the shadow screen
            pla
            tay
            pla
            tax
            lda  mode8020
            cmp  #MODE80
            beq  is80
is20        pla
            jmp  putchxy20         ; Will return from here
is80        pla
            jmp  putchxy80         ; Will return from here
.)


            ;-----------------------------------------
            ; putchxy20
            ; Print a character to screen at position
            ; specified on 20 column screen
            ;-----------------------------------------
            ; ACC - character to print (ASCII)
            ;   X - Column on simulated screen
            ;   Y - Row on simulated screen
            ;-----------------------------------------
putchxy20   .(
            ; TODO use different location than CHRADDR, maybe SCRADDR

            ; See if in visible quarter of screen
            cpx  viewcolge
            bcs  ge
            jmp  done
ge          cpx  viewcollt
            bcc  inView
            jmp  done

inView      ; The location is in view
            pha               ; Push character to stack
            sec               ; Align x with first column
            txa               ; |
            sbc  viewcolge    ; |
            tax               ; /

            ; Find column
findCol     txa
            sta  CHRADDR      ; Store column to CHRADDR  - lsb
            lda  #$00         ; |
            sta  CHRADDR+1    ; /   msb


            ; Find location of row
findRow     cpy  #00
            beq  addScrAddr
            ; Add number of real columns to address
            clc
            lda  CHRADDR      ; lsb
            adc  #RNUMCOL20
            sta  CHRADDR      ; lsb
            bcc  noCarry
            inc  CHRADDR+1    ; msb
noCarry     dey
            jmp  findRow

            ; Add $1E00 as address of screen
addScrAddr  clc
            lda  CHRADDR+1    ; msb
            adc  #>SCRBASE
            sta  CHRADDR+1    ; msb

storeCh     pla
            jsr  asctocbm
            ldy  #00
            sta  (CHRADDR), y
done        rts
.)


            ;-----------------------------------------
            ; putchxy80
            ; Print a character to screen at position
            ; specified on 80 column screen
            ; This will print ASCII 32-95
            ;-----------------------------------------
            ; ACC - character to print (ASCII)
            ;   X - Column on simulated screen
            ;   Y - Row on simulated screen
            ;-----------------------------------------
putchxy80   .(
            cmp  #95
            bcc  storeCh      ; If <= 95
            and  #$5F         ; Drop bit 5 (upcase)
storeCh     pha               ; Push character to stack
            lda  #$00         ; Zero CHRADDR
            sta  CHRADDR      ; |
            lda  #$00         ; |
            sta  CHRADDR+1    ; /

            ; Find which quarter of a character definition
            ; NOTE This counts the quarters from right to left
            ; TODO tidy this up
            txa
            and  #3           ; Look at right 2 bits
            sta  CHQUARTER
            lda  #3
            sec
            sbc  CHQUARTER
            sta  CHQUARTER

            ; Find which half of a character definition
            ; and store the offset
            tya
            clc
            and  #1
            asl               ; Multiply by 8
            asl               ; |
            asl               ; /
            sta  CHHALFOFF

            ; TODO Put this where zero CHRADDR is above
            ; Find location of simulated column pair
findCol     txa
            lsr               ; Quarter the column
            lsr               ; |
            sta  CHRADDR      ; /   lsb

            ; Find location of row
            tya               ; Half the row
            lsr               ; |
            tay               ; /
findRow     cpy  #00
            beq  mul16
            ; Add number of real columns to address
            clc
            lda  CHRADDR      ; lsb
            adc  #RNUMCOL80
            sta  CHRADDR      ; lsb
            dey
            jmp  findRow


mul16        ; TODO find better name

            ; Multiply by 16 to find location of character
            ; Shift left 4 times to multiply by 16
            asl  CHRADDR       ; lsb
            rol  CHRADDR+1     ; msb
            asl  CHRADDR       ; lsb
            rol  CHRADDR+1     ; msb
            asl  CHRADDR       ; lsb
            rol  CHRADDR+1     ; msb
            asl  CHRADDR       ; lsb
            rol  CHRADDR+1     ; msb

            ; Add $1000 as address of character map
            clc
            lda  CHRADDR+1    ; msb
            adc  #>CHRMAPBASE
            sta  CHRADDR+1    ; msb

            ; Add CHHALFOFF offset to character map address
            ; This locates in the top or bottom half of the character
            ; definition
            clc
            lda  CHRADDR
            adc  CHHALFOFF
            sta  CHRADDR

            ; Copy the character to the screen
copyCh      lda  #00
            sta  CHDEFADDR+1
            pla               ; Pull character off stack
            sec
            sbc  #SPACE       ; Font definitions are from space onwards
            sta  CHDEFADDR    ; Multiply character by 2
            asl  CHDEFADDR    ; |
            rol  CHDEFADDR+1  ; /

            clc
            lda  CHDEFADDR
            adc  #<fontDef     ; lsb
            sta  CHDEFADDR
            lda  CHDEFADDR+1
            adc  #>fontDef     ; msb
            sta  CHDEFADDR+1


            lda  #1           ; Init bitmasks in self-modifying code
            sta  andL+1       ; |
            sta  andR+1       ; |
            sta  realignL-1   ; /
            sta  realignR-1   ; /

            ; Put character definition into 8 bytes using bits 1 and 2
            ldx  #0
getLoop     ldy  #0
            lda  (CHDEFADDR),y
andL        and  #1
            ldy  #1           ; Align the left bit
realignL    dey               ; |
            beq  alignDoneL   ; |
            lsr               ; |
            jmp  realignL     ; /
alignDoneL
            asl
            sta  CHDEF, x
            ldy  #01
            lda  (CHDEFADDR), y
andR        and  #1
            ldy  #1           ; Align the right bit
realignR    dey               ; |
            beq  alignDoneR   ; |
            lsr               ; |
            jmp  realignR     ; /
alignDoneR
            ora  CHDEF, x

            ; Put character in correct quarter
            ldy  CHQUARTER
realignQ    beq  alignDoneQ
            asl
            asl
            dey
            jmp  realignQ
alignDoneQ

            sta  CHDEF, x
            asl  andL+1       ; Self-modify code to move to next bits
            asl  andR+1       ; |
            inc  realignL-1   ; /
            inc  realignR-1   ; /
            inx
            cpx  #8
            bne  getLoop


            ; Copy the character to the character definition.
            ; This gets the existing definition, clears the bits
            ; where this character will go and ORs the remaining
            ; bits with the new character.
            ldy  #7
            lda  CHQUARTER
            cmp  #00
            beq  q0
            cmp  #01
            beq  q1
            cmp  #02
            beq  q2

q3          lda  (CHRADDR),y
            and  #$3F
            ora  CHDEF, y
            sta  (CHRADDR),y
            dey
            bpl  q3
            jmp  done

q2          lda  (CHRADDR),y
            and  #$CF
            ora  CHDEF, y
            sta  (CHRADDR),y
            dey
            bpl  q2
            jmp  done

q1          lda  (CHRADDR),y
            and  #$F3
            ora  CHDEF, y
            sta  (CHRADDR),y
            dey
            bpl  q1
            jmp  done

q0          lda  (CHRADDR),y
            and  #$FC
            ora  CHDEF, y
            sta  (CHRADDR),y
            dey
            bpl  q0

done        rts
.)



            ;-----------------------------------------
            ; storexyShd
            ; Store a character in the shadow screen
            ;-----------------------------------------
            ; ACC - character to print (ASCII)
            ;   X - Column on simulated screen
            ;   Y - Row on simulated screen
            ;-----------------------------------------
storexyShd  .(
            ; Add column to shadScr8020 (shadow screen)
            pha               ; Push character to stack
            lda  inRedraw     ; If in redraw then return
            beq  findCol      ; |
            pla               ; |
            rts               ; /

findCol     clc
            txa
            adc  #<shadScr8020  ; lsb
            sta  SHADADDR       ; lsb
            lda  #00
            adc  #>shadScr8020  ; msb
            sta  SHADADDR+1     ; msb


            ; Find location of row
findRow     cpy  #00
            beq  storeCh
            ; Add number of columns (80) to address
            clc
            lda  SHADADDR     ; lsb
            adc  #80
            sta  SHADADDR     ; lsb
            bcc  noCarry
            inc  SHADADDR+1   ; msb
noCarry     dey
            jmp  findRow


storeCh     pla
            ldy  #00
            sta  (SHADADDR), y
done        rts
.)


            ;----------------------------------------
            ; puts
            ; Print string
            ;----------------------------------------
            ; STRADDR - Location of zero terminated
            ;           string.  This location is
            ;           left at end of string after
            ;           function returns.
            ;----------------------------------------
puts        .(
loop        ldy  #00
            lda  (STRADDR), y
            beq  done
            jsr  putch
            inc  STRADDR      ; Increment STRADDR
            bne  incDone      ; |
            inc  STRADDR+1    ; /
incDone
            jmp  loop
done        rts
.)


            ;----------------------------------------
            ; getx
            ; Returns X (column) value of cursor
            ; in ACC
            ;----------------------------------------
getx        lda  crx
            rts


            ; Convert ASCII to PETSCII
asctocbm    .(
            cmp  #32
            bcs  ge32
            cmp  #13          ; If acc==13, return
            beq  done
            cmp  #8
            beq  isDel
            jmp  zero
ge32        cmp  #65          ; If acc>=32 and acc<=64, return
            bcc  done
            cmp  #91
            bcs  ge91
            ; If acc>=65 and acc<=90 then acc=acc+128, return
            clc
            adc  #128
            jmp  done
ge91        cmp  #96          ; If acc>=91 and acc <=95, return
            bcc  done
            cmp  #97          ; If acc >= 97
            bcs  ge97
            ; If acc==96 or acc>=123 or (acc<32 and acc!=8 and acc!=13)
zero        lda  #00
            jmp  done
ge97        cmp  #123
            bcs  zero
            ; If acc>=97 and acc<=122 then acc=acc-32, return
            sec
            sbc  #32
            jmp  done
            ; If acc==8 then acc=20, return
isDel       clc
            lda  #20
done        rts
.)

;====================================
; Data
;====================================

mode8020    .byt MODE20       ; Whether in 80 or 20 colummn mode
crx         .byt 0            ; Cursor x position on simulated screen
cry         .byt 0            ; Cursor y position on simulated screen
viewcolge   .byt 0            ; Viewable window for 20 columns - col >= val
viewcollt   .byt 0            ; Viewable window for 20 columns - col < val

tmpAcc      .byt 0            ; TODO move this to putchxy?
inRedraw    .byt 0            ; In middle of redraw operation

#include "fontdef.a65"        ; The font definitions
